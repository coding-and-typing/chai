# 一、汉字自动拆分总论

如果您认真阅读了用户文档，一定会对汉字自动拆分的实现感到惊奇。的确，汉字的形状变化万千，各种编码方案对其的拆分也各不相同，数不胜数，异常复杂。

然而，汉字的可能拆分方式是无穷无尽的吗？我们知道，汉字的笔画数量是有限的，如果我们限制拆分以笔画为最小单位，拆出的字根中每个字根至少包含一个笔画，则汉字的可能拆分方式的数量必然是一个有限大——尽管确实很大——的数。枚举出有限多的拆分方式中，我们再根据确定的规则自动化选取最佳的拆分，就实现了汉字自动拆分。本系统之所以可行，正是基于如此简单的原理。

那么汉字的可能拆分数量大约有多大呢？经过简单的计算，它大约略小于笔画数量的阶乘。一个十笔的字有数十万种拆分，而一个二十笔的字的拆分数量已经超出了任何计算机所能存储的极限。因而如上原理的直接应用又是不可能的。

所幸，基于汉字作为表意文字的特性，绝大多数汉字内在地划分成多个部件（例如形声字、会意字等），部件又可以划分为更小的部件，经过逐级分解之后可以用六七百个基本部件以简单的几何关系组合而成。而对于绝大多数的形码而言，字根数量不过二三百个，所进行的拆分也基本上是针对基本部件的拆分，极少出现一个字根横跨两个基本部件的情况。因此我们引入了本系统最重要的一个假设：

> 分部假设：含有多个部件的汉字的拆分结果，可以近似地由每个部件的拆分结果，以及这些部件相互组合的几何关系决定。

基本部件的笔画数量少，因而对它们进行枚举是可以做到的。由此我们引出了本系统的顶层架构：

1. 基本部件拆分为字根：由于不同编码方案天差地别，为了最大程度满足它们的需求，我们针对基本部件枚举所有可能的拆分，然后以拆分规则筛选出唯一的拆分；
2. 用基本部件确定其他汉字：将其他汉字表示为由基本部件构成的树状结构；
3. 根据「基本部件的拆分」和「其他汉字的树状结构」进行编码。

【这里需要图片】

# 二、基本部件拆分

## 1 「文」数据库简介

基本部件是拆分算法所要处理的对象。处理过程中，我们可能需要用到许多种可能的信息，但任何信息都是可以基于图形信息推导得出的。因此，本系统仅存储最原始的数据，即「这个基本部件是怎么写出来的」。

具体而言，我们：

- 将基本部件表达为多个笔画；
- 将笔画表达为笔画类别和多个绘制命令；
- 每个绘制命令由绘制种类和绘制参数组成，具体可参见 Wiki 页面中的「「文」数据库开发规范」。

```yaml
一:
  - [横, [m, 25, 470], [h, 967]]
丁:
  - [横, [m, 52, 130], [h, 918]]
  - [竖钩, [m, 508, 132], [v, 833]]
```

在程序中，为了实现上述数据的封装，每个笔画由一个 Stroke 对象表示，每个字由一个 Char 对象表示。当我们取一个字的其中一部分笔画构成一个新字时，我们称新字是源字的「切片」，切片也用一个 Char 对象表示。

## 2 退化映射

根据架构，我们首先需要将基本部件拆分为字根。但是，当我们利用上述坐标数据时，我们就面临着一个问题：用户可能希望将不同的字中不同的切片视为同一字根，尽管这些切片的坐标数据不完全一样。例如，「串」中的两个「口」上面的小、下面的大，坐标数据并不相同，但通常用户会将其看作同一字根。如何实现呢？

一种思路是，直接利用上述全部信息，结合人工智能的分类方法进行分类。然而，这将会花费巨大的运算资源（例如，请了解手写数字的神经网络分类模型），于是我们思考的是，上述信息中是否存在某些简单、信息量少的「关键部分」，使得我们仅通过这些关键部分就能有效的区分不同字根？

「拆」为此进行了尝试，将这种对一个切片提取关键信息的函数称为「退化映射」，得到的关键信息称之为「特征」。这样，我们将一个切片经退化映射处理，得到的特征与字根的特征进行比较，如果它的特征与某个字根的特征相等，就可以将它等同于该字根。相反，如果它不与任何字根的特征相等，它就是一个无效切片，不能作为拆分的一部分。

在实际操作中，我们可能会提取多种不同的关键信息，然后将它们组合起来成为一个字的特征。此时每种信息称为一个「域（field）」，生成这个域的函数称为域函数。

为了便于查询，我们计算所有字根的特征，形成一个以特征索引用户字根的字典；此后，每当我们获得了一个基本部件的切片，我们就能取其特征并在字典中查找，查找得到则为有效切片，否则为无效切片。

以下为伪代码：

```python
def degenerator(objectChar):
    '''
    功能：退化函数
    输入：objectChar 是一个 Char 类型的对象，可以是字、字根或切片，里面存储着笔画序列信息
    输出：特征
    '''
    characteristicString = '' # 用字符串表达特征
    for fieldFunction in fieldFunctionList:
        field = fieldFunction(objectChar) # 使用某种域函数，获得一个域
        characteristicString += field # 将域加到特征上
    return characteristicString

def genDegeneracy(rootSet):
    '''
    功能：用于生成用户字根退化字典的函数
    输入：rootSet 字根集，每个字根是一个 Char 对象
    '''
    degeneracy = {} # 一个{退化对象:用户字根}字典
    for objectRoot in rootSet:
        characteristicString = degenerator(objectRoot) # 退化用户字根的对象字
        degeneracy[characteristicString] = objectChar # 写入退化字典
    return degeneracy        
```

## 3 幂字典生成

我们现在讨论：给定一个基本部件，我们可以从其中拆出哪些字根？为了满足不同方案的需求，「拆」采用了比较激进的方案——枚举一个基本部件的所有切片，计算该切片的特征，然后在退化字典中查找它所对应的字根，如果能够找到则标记为有效切片，找不到则标记为无效切片。

那么，一个基本部件最多能形成多少种切片？显然，对于一个 n 笔的字，每个笔画都有取和不取两种状态，因而切片就有 2 的 n 次方种可能性。我们因此可以用 n 个布尔值（即 0 或 1）组成的向量来表达这一切片。例如：

- 设字 c 是含有 5 笔的字，则它的所有切片都可以用一个**含有 5 个布尔值的向量**表达；
- 取字 c 前 2 笔和最后一笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的向量应该是 (1, 1, 0, 0, 1)；
- 取完切片 s 之后，余下部分 r 对应的向量应该是 (0, 0, 1, 1, 0)。


进一步抽象之后，我们很自然地联想到可以使用二进制数来表达切片，这样的好处是我们可以通过位运算来快速处理切片。例如：

- 设字 c 是含有 5 笔的字，则它的所有切片都可以用一个**含有 5 个位的二进制数**表达；
- 取字 c 前 2 笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的二进制数应该是 11001，转换为十进制数是 25；
- 取完切片 s 之后，余下部分 r 对应的向量应该是 00111，转换为十进制数是 6。

现在，我们就可以通过遍历 1 ~ 2<sup>n</sup>-1 的所有数字来寻找一个字的所有有效切片：

```python
def genPowerDict(objectChar):
    """
    输入：对象字
    输出：幂字典
    """
    objectChar.powerDict = {}
    # 获取对象字的笔画数，我们不妨仍设为 5；
    l = objectChar.charLen
    # 生成掩码列表，<< 为位左移运算，得到的结果为 [10000, 01000, 00100, 00010, 00001]
    mask = [1 << (l-i-1) for i in range(l)]
    for k in range(1, 2**l):
        sliceStrokeList = []
        # 对于每个数 k，我们遍历所有掩码，如果数 k 与某个掩码按位与后不为 0，那么说明该数的这一位为 1，这等价于该切片取了这一位对应的笔画
        for idx, item in enumerate(mask):
            if k & item:
                sliceStrokeList.append(objectChar.strokeList[idx])
        # 根据切片的笔画序列生成一个 Char 对象，然后经过 degenerator 运算获取特征；在退化字典中查找该特征：
        #   - 如果查找到了，则将数 k 及对应的字根作为一个键值对存储在幂字典中；
        #   - 如果查找不到，其值将会记为 None。
        characteristicString = degenerator(Char('', sliceStrokeList))
        objectChar.powerDict[k] = degeneracy.get(characteristicString)
```

现在，幂字典中记录了每个切片分别对应哪个字根（或者不对应任何字根），由此我们可以正式进入一个字的拆分环节。

## 4 可行拆分集生成

在未开始拆分之前，我们将一个字的状态用 2<sup>n</sup>-1 表示，我们将它称为剩余数。每当我们从这个字上取下一个切片时，我们就将这个切片对应的数从剩余数中减去，得到新的剩余数。那么给定任意一个剩余数，我们如何知道从它身上能取下哪些切片呢？

首先，我们要引入一个限定原则（首笔序原则），即拆分得到的字根列表是按它们首笔笔顺排列的。因此，在每次从没有拆完的部分中取切片的过程中，必须取到该部分的第一笔。例如，第一次拆分时必须取到该字的第一笔。

```python
def nextRoot(n):
    '''
    给出从剩余数中取下一个切片的可能性列表，每个切片都应该包含该部分的第一笔
    '''
    powerList = [0]
    # 这里我们假设剩余数 n 为 00110，那么我们每次考虑 n 的一个非零位（即剩余部分的一个笔画，计算
    while n: # 直到当前序列所有「1」位都被置0之前，做：
        t = n & (n-1) # n - 1 = 00101，位与运算得到 t = 00100，含义是删除剩余部分的最后一笔
        m = n - t # m = 00010，含义是剩余部分的最后一笔
        powerList += [x + m for x in powerList] # 该笔画可取可不取，所以列表应该扩增为原来的两倍，前一半不含该笔画，后一半含有该笔画，这里我们得到 [0, 10]
        n = t # 将 00100 设为
    # 经过两次迭代，powerList 变为 [0, 10, 100, 110]，这恰好是从剩余数 00110 中所能取出的所有切片，又因为首笔序的限制，必须取到第一笔，所以我们删除这个列表中的前一半
    return powerList[len(powerList)//2:]
```

所以，拆分算法可以概括为：

- 建立两个列表记录拆分状态，一个为未完成列表，一个为完成列表，向未完成列表中加入初始值 (2<sup>n</sup> - 1)，即将整个部件作为一个剩余数；
- 取未完成列表中的某个拆分，将它的最后一个数（即剩余数）经由 `nextRoot` 函数处理，得到所有可能切片，用幂字典检验它们的有效性，如果无效则予以剔除，有效则保留；
- 如果切片恰好等于剩余数，说明这个基本部件被拆完了，我们将它添加到已完成列表中；否则用剩余数减去新切片，将它添加到未完成列表中，形成堆栈；
- 重复上述过程，直到未完成列表全部被清空。

```python
def genSchemeList(objectChar):
    '''
    形成包含所有可能拆分的列表
    '''
    l = objectChar.charlen
    # 建立两个列表记录拆分状态
    uncompletedList = [(2**l - 1, )] # 未拆完的拆分会留在这里，当这个列表不是空列的时候，迭代继续
    completedList = [] # 完成了的拆分会移动到这里，作为最后的输出
    while uncompletedList: # 当未拆完列表非空时，做：
        newUncompletedList = []
        for scheme in uncompletedList: # 对于每个未拆完的拆分
            residue = scheme[-1] # 选取最后一个对象，实际上即是「剩余」
            nrList = nextRoot(residue) # 找到所有可能的切片
            # 利用powerDict过滤出所有有效切片（无效切片的值是None，被滤除，参考genPowerDict）
            rootList = list(filter(lambda x: objectChar.powerDict[x], nrList)) 
            for root in rootList: # 对于每个有效切片
                if root != residue: # 如果跟「剩余」非等大，即还没拆完
                    newUncompletedList.append(scheme[:-1] + (root, residue - root)) # 扩张一个拆分
                else: # 新拆出的字根和原有剩余一样大，说明已拆完
                    completedList.append(scheme) # 移动到拆完列中
        uncompletedList = newUncompletedList
    objectChar.schemeList = completedList # 返回给对象字
```

## 5 择优函数

通过上面的流程，我们不难理解，实际上可能的拆分有很多，如何获取我们目标要求的那个，这就是择优函数需要做的事情。

择优函数应该如何表达？我们知道，大多数形码方案会提出几条拆分规则，例如「根少优先」等等。用数学的语言表达，每条规则定义了一个函数，这个函数的作用对象是拆分方案，而其作用结果是给出一个可比较的对象（例如整数或实数），在所有的拆分方案中只有取到最大值或最小值的才能通过此轮筛查，其余将被筛去。

例如，我们得到了 10 个拆分方案，令「根少优先」所定义的函数作用于这 10 个拆分方案时，我们得到其中 3 个方案将字拆为 2 个字根，5 个方案将字拆为 3 个字根，2 个方案将字拆为 4 个字根。那么，我们发现最小值为 2，筛去所有不为 2 个字根的拆分方案，剩余 3 个拆分方案；然后我们再应用其他规则处理剩余的 3 个方案直到唯一为止。

我们形象地将每个这样的函数称为「筛（sieve）」。

以下为伪代码：

```python
def selector(objectChar):
    # 对于每个筛，对拆分方案的列表进行过滤使得只保留那些函数值取到最小值的拆分
    for sieve in sieveList:
        evalList = [sieve(objectChar, scheme) for scheme in objectChar.schemeList]
        bestEval = min(evalList)
        objectChar.schemeList = list(filter(lambda scheme: sieve(objectChar, scheme) == bestEval, objectChar.schemeList))
    # 理论上经过选择器序贯处理后应该只剩下一个拆分方案。如果不是这样，报错
    if len(objectChar.schemeList) == 1:
        return tuple(objectChar.powerDict[x] for x in objectChar.schemeList[0])
    else:
        raise ValueError('您提供的拆分规则不能唯一确定拆分结果。例如，字「%s」有如下拆分方式：%s' % (objectChar.name, objectChar.schemeList))
```

如果成功，则每个基本部件都将产生一个最优拆分方案，存储到 `objectChar.bestScheme` 中。

# 三、部件树

所有不属于基本部件的汉字均以键值对的形式存储在 `字.yaml` 中，其值为一个表达式。一个表达式由一个二元运算符和两个操作对象组成，例如：

```yaml
他: [h, 亻, 也]
```

其中 `h` 为左右结构运算符，`亻` 和 `也` 为操作对象。当没有合适的部件来表达一个操作对象的时候，值也可以是另一个表达式，例如：

```yaml
前: [z, 前上, [h, 青下, 刂]]
```

在程序中，为了便于运算，我们定义了树类（`Tree`），将表达式处理为一个树对象。初始化该树对象时，我们不仅存储了该表达式的结构，还将每个值继续展开直到基本部件，例如：

```yaml
价: [h, 亻, 介]
```

这里 `亻` 是基本部件，而 `介` 不是，它由 `人` 和 `齐下` 两个更基本的部件组成。总而言之，`Tree` 对象以 `name` 储存汉字名称，`structure` 存储结构运算符，`first` 和 `second` 存储运算符的操作对象，这些对象仍然是一个 `Tree` 对象，如此迭代展到直到基本部件，它的 `first` 和 `second` 值为 `None`，也即基本部件是树的末端节点。

# 四、Schema 类概览

到目前为止，您已经了解了本系统的所有要素，现在让我们将它们组装成一个 `Schema` 类。

1. 构造函数 `Schema.__init__()`
   - 功能：首先加载两个数据库，并将字数据库解析为树，存入 `Schema.tree` 字典中。然后根据方案名加载 `xxx.schema.yaml`，首先在当前工作目录下寻找，如果找不到则在模块包的预置文件夹中寻找，如果再找不到则报错。
   - 输入：方案名 `schemaName`；
   - 输出：存储为类成员 `Schema.wen`, `Schema.zi`, `Schema.tree`, `Schema.schema`, `Schema.charList`，然后调用 `Schema.parseSchema()`；
2. 解析方案函数 `Schema.parseSchema()`：
   - 功能：分析用户的配置文件，生成字根集和退化字典；同时还检验笔画是否定义完全，不完全则报错；
   - 输入：无；
   - 输出：存储为类成员 `Schema.rootSet` 和 `Schema.degeneracy`；
3. 自定义域与自定义筛函数 `Schema.setField()`, `Schema.setSieve()`：
   - 功能：在初始化时，对象引入了私有成员 `Schema.__fieldDict` 和 `Schema.__sieveDict`，它们负责把文字版的退化映射和择优函数与程序中具体的函数联系起来，例如「根少优先」关联到 `schemeLen` 函数；在这一步用户如果编写了自己的域函数或者筛，则可以通过这个函数进行注册；
   - 输入：函数中文名 `name` 和实际函数 `function`；
   - 输出：更新类成员 `Schema.__fieldDict()` 和 `Schema.__sieveDict()`
4. 幂字典生成函数 `Schema.genPowerDict()`：
   - 功能：找出基本部件的所有有效切片，构造切片到用户对象字的幂字典；
   - 输入：对象字 `objectChar`；
   - 输出：存储为对象字 `objectChar` 的类成员 `powerDict`；
5. 拆分方案列表生成函数 `Schema.genSchemeList()`：
   - 功能：根据幂字典生成；
   - 输入：带 `powerDict` 的对象字 `objectChar`；
   - 输出：存储为对象字 `objectChar` 的类成员 `schemeList`；
6. 最优拆分方案生成函数 `Schema.genBestScheme()`：
   - 功能：利用估值函数对一个拆分进行估值，然后利用优化函数将最优化的拆分筛选出来；
   - 输入：带 `schemeList` 的对象字 `objectChar`；
   - 输出：将在择优逻辑下最优拆分 bestScheme 传给对象字 `objectChar`；
7. 运行函数 `Schema.run()`：
   - 功能：对于每个基本部件，依次运行 `genPowerDict(), genSchemeList(), genBestScheme()`，所得到的最优拆分方案存入字典；
   - 输入：无；
   - 输出：存储为类成员 `Schema.component()`；

这样，用户只需要如下三行代码

```python
from Chai import Schema
my_schema = Schema('my_file_name')
my_schema.run()
```

即可运行拆分，得到 `my_schema.component` 和 `my_schema.tree` 用于自己编码。
